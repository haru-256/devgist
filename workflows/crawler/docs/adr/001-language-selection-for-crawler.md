# ADR-001: 論文収集クローラーの実装言語としてPythonを採用

## Status (ステータス)

Accepted (承認済み) - 2026-01-20

## Context (背景・課題)

### 何を作ろうとしているのか？

DBLP等の学術データベースやテックブログから論文・記事情報を収集するクローラーを開発する。主要な推薦システム・データマイニング系カンファレンス（RecSys、KDD、WSDM等）の論文メタデータを継続的に取得し、将来的にはレコメンド機能やデータ分析への拡張を想定している。

さらに、zen.dev、Qiita、はてななどのテック記事もRSSフィードを通じて収集し、技術情報のキュレーションも行う予定である。

### どのような制約や要件があるのか？

1. **不定形なデータ構造**: DBLP、Semantic ScholarなどのAPIは、レスポンスの構造が動的に変化する
   - 例: 著者が1人の時は`dict`、複数の時は`list`で返る
2. **多様なデータソース**: 学術APIに加え、RSSフィード（zen.dev、Qiita、はてな等）からテック記事も収集
3. **開発速度**: プロトタイプから本番環境まで、素早い反復開発が必要
4. **将来の拡張性**: 収集データを用いたNLP解析やレコメンドロジックの実装を予定

### 比較検討した選択肢は何か？

| 項目 | Python | Go |
|------|--------|-----|
| 型システム | 動的型付け + Pydantic | 静的型付け |
| 並行処理 | asyncio | Goroutine |
| データ処理 | pandas, scikit-learn等が充実 | 限定的 |
| デプロイ | 依存関係含む | シングルバイナリ |
| 学習コスト | 既存スキル活用可能 | 新規学習必要 |

## Decision (決定事項)

**クローラーの実装言語としてPythonを採用する。**

また、堅牢性を担保するため、型定義とバリデーションには **Pydantic** を使用する。

### 決定の根拠

1. **不定形データへの対応力**: Pythonの動的型付けと`isinstance`分岐により、API仕様の揺らぎを低コストで吸収できる
   - 実装例: [`usecase/dblp.py`](../../usecase/dblp.py)の`_parse_authors`メソッド（~10行で実装）
   - Go実装では~30行のtype assertionとカスタムUnmarshaller が必要

2. **エコシステムの活用**: データ収集→分析→モデリングを単一言語で完結
   - 将来のpandas/scikit-learn/transformers統合が容易
   - 言語切り替えによる認知負荷がない

3. **Pydanticによる堅牢性**: 実行時の厳格なバリデーションで、Goの静的型付けに近い安全性を実現
   - 実装例: [`domain/paper.py`](../../domain/paper.py)

4. **RSS/フィード処理の成熟度**: `feedparser`ライブラリにより、RSS 2.0/Atom/JSON Feed等あらゆる形式に対応
   - zen.dev、Qiita等のテック記事収集が数行で実装可能
   - HTMLパース（Beautiful Soup、lxml）による本文抽出も容易
   - 記事の自動要約・分類等のNLP処理へシームレスに接続

## Consequences (結果・影響)

### Positive (メリット)

1. **開発速度**: 3週間でプロトタイプから本番品質の実装完了
2. **柔軟性**: API変更への迅速な対応（著者フィールド対応: ~10行の実装）
3. **品質保証**: 78個の包括的なテスト（DBLP 11、SemanticScholar 17、Arxiv 9、Unpaywall 18、Paper 15、RobotGuard 5）
4. **将来性**: データ活用への明確なパス（NLP、レコメンド等）

**定量的な成果:**

- テストカバレッジ: 78テスト、100%パス
- コード品質: mypy、ruff全チェックパス
- 保守性: 全クラス・メソッドにdocstring完備

### Negative (デメリット)

1. **並行処理性能**: GoのGoroutineと比較して、asyncioはメモリ効率やCPU処理で劣る
    - 現状規模（数百URL）では問題なし
2. **デプロイサイズ**: Pythonランタイム含むため、コンテナイメージが大きい
    - 現状では許容範囲（~500MB程度）
3. **起動速度**: Goのシングルバイナリと比較して遅い
    - バッチ処理のため影響軽微

### Risks / Future Review (将来の課題)

以下の**定量的な閾値**を超えた場合、Goへの移行（リプレイス）またはマイクロサービス化を検討する：

#### 1. パフォーマンスの限界

**閾値:**

- 監視URL数: 10万件超
- 同時接続数: 1,000超
- メモリ使用量: 4GB超（単一プロセス）
- CPU使用率: 80%継続（asyncioボトルネック）

**移行理由:** Goroutineによる並行処理でハードウェアコストを大幅削減可能

#### 2. コスト最適化の必要性

**条件:**

- FaaS環境での運用において、コールドスタート時間が3秒超
- コンテナイメージサイズが500MB超で、課金が顕著
- 月間実行回数が100万回超

**移行理由:** Goでイメージサイズを20MB以下、起動時間を100ms以下に削減可能

#### 3. 仕様の固定化

**条件:**

- スクレイピングロジックが6ヶ月以上変更なし
- APIエンドポイントの追加頻度が年1回以下
- メンテナンスフリー運用を望むフェーズ

**移行理由:** シングルバイナリデプロイで依存関係管理が不要、長期安定運用に適する

## 参照

### 実装

- [DBLPSearch](../../usecase/dblp.py) - DBLP API連携（不定形データ処理の実例）
- [SemanticScholarSearch](../../usecase/semantic_scholar.py) - Semantic Scholar連携
- [ArxivSearch](../../usecase/arxiv.py) - arXiv連携（セキュアなXMLパース）
- [UnpaywallSearch](../../usecase/unpaywall.py) - Unpaywall連携
- [Paper Model](../../domain/paper.py) - Pydanticによる型定義

### テスト

- [Test Suite](../../tests/) - 78個のテストによる品質保証

### 関連ドキュメント

- [README.md](../../README.md) - プロジェクト全体のドキュメント
- [ADRテンプレート](./_template.md)
