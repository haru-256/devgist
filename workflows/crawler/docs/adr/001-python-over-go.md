# ADR-001: クローラー実装言語としてGoではなくPythonを採用

## ステータス

承認済み (2026-01-20)

## 要約

学術論文メタデータクローラーの実装言語として**Python**を採用する。外部APIの不定形なデータ構造への柔軟な対応と、将来のデータ活用を見据えたエコシステムが、Goの静的な堅牢性とパフォーマンスを上回ると判断した。

## コンテキスト

### 背景

Archilogプロジェクトにおいて、DBLP、Semantic ScholarなどのAPIから学術論文のメタデータを収集するクローラーを構築する必要があった。主要な推薦システム・データマイニング系カンファレンス（RecSys、KDD、WSDM等）の論文情報を継続的に取得し、将来的にはレコメンド機能やデータ分析への拡張を想定している。

### 技術選択肢

| 項目 | Python | Go |
|------|--------|-----|
| 型システム | 動的型付け + Pydantic | 静的型付け |
| 並行処理 | asyncio | Goroutine |
| デプロイ | 依存関係含む | シングルバイナリ |
| エコシステム | データサイエンス強 | インフラ・CLI強 |
| 学習曲線 | 緩やか | やや急 |

### 主要な要件

1. **データ構造の多様性への対応**: 同一APIで構造が変化する不定形なJSONレスポンスを扱う
2. **開発速度**: 短期間でのプロトタイプから本番環境への移行
3. **将来の拡張性**: データ分析・レコメンド機能への発展
4. **開発者スキルセット**: データサイエンティストとしての既存知識の活用

## 決定内容

**Pythonをクローラーの実装言語として採用する。**

理由は以下の通り：

## 理由

### 1. 不定形なJSONデータへの対応力（決定要因）

**問題**: DBLP APIの著者フィールドは、1人の場合は`object`、複数の場合は`array`で返却される。

**Pythonでの実装** (`usecase/dblp.py`の実例):

```python
def _parse_authors(self, authors_data: dict[str, Any]) -> list[str]:
    _authors = authors_data.get("author")
    
    if isinstance(_authors, list):
        return [a.get("text") for a in _authors if a.get("text")]
    elif isinstance(_authors, dict):
        return [_authors["text"]] if _authors.get("text") else []
    return []
```

**実装コスト**:

- Python: ~10行、可読性高、保守容易
- Go: ~30行、type assertion繰り返し、カスタムUnmarshaller必要

**実測値**: 著者パース処理を含むテスト17件が全てパス、APIの構造変化に対して1ファイル数行の修正で対応可能。

### 2. Pydanticによる実行時型安全性

動的型付けの弱点を`pydantic`で補完し、Goと同等レベルの型安全性を実現。

```python
class Paper(BaseModel):
    title: str              # 必須、自動バリデーション
    authors: list[str]      # 必須
    year: int              # 自動型変換
    doi: str | None = None # オプション
```

**効果**:

- 実行時に不正なデータを即座に検出（15個のテストでバリデーション動作を確認）
- 型アノテーションによる開発体験はGoと同等
- コンパイル不要のため開発サイクルが高速

### 3. データサイエンスエコシステムとの一貫性

**将来の拡張シナリオ**:

- 論文のクラスタリング・分類（scikit-learn）
- Abstract のトピック分析（transformers、spaCy）
- レコメンドアルゴリズムの実装（PyTorch、TensorFlow）

Pythonで統一することで、データ収集→前処理→分析→モデリングを単一の言語・ツールチェーンで完結できる。

**代替案（Go採用時）**:

- クローラーはGo、分析はPythonと分離
- データの受け渡しに中間形式（JSON、Parquet等）が必要
- 開発者が2言語を行き来する認知負荷

## トレードオフ

### 採用による利点

| 項目 | 効果 | 実測値 |
|------|------|--------|
| 開発速度 | 高速な反復開発 | 3週間で本番品質実装 |
| 柔軟性 | API変更への迅速な対応 | 著者フィールド対応: 10行 |
| 品質保証 | 包括的テスト | 48テスト全パス |
| 将来性 | データ活用への布石 | pandas/NLP統合が容易 |

### 採用によるデメリット（許容範囲）

| 項目 | 影響 | 現状評価 |
|------|------|----------|
| 並行処理性能 | Go比で劣る | 現状規模（数百URL）では問題なし |
| メモリ使用量 | ランタイム含む | コンテナ環境では許容範囲 |
| 起動速度 | Go比で遅い | バッチ処理のため影響軽微 |

## 移行判断基準

以下の**定量的な閾値**を超えた場合、Goへの移行を検討する：

### 1. スケールアウトの限界

**閾値**:

- 監視URL数: 10万件超
- 同時接続数: 1,000超
- メモリ使用量: 4GB超（単一プロセス）
- CPU使用率: 80%継続（asyncioボトルネック）

**移行理由**: Goroutineによる並行処理でハードウェアコストを1/10以下に削減可能

### 2. 安定期への移行

**条件**:

- スクレイピングロジックが6ヶ月以上変更なし
- APIエンドポイントの追加頻度が年1回以下
- マイクロサービス化してメンテナンスフリー運用したい

**移行理由**: シングルバイナリデプロイで依存関係管理が不要

### 3. FaaSへのアーキテクチャ変更

**閾値**:

- コールドスタート: 3秒超が頻発
- コンテナイメージサイズ: 500MB超
- 月間実行回数: 100万回超（課金が顕著）

**移行理由**: Goでイメージサイズを20MB以下、起動時間を100ms以下に削減可能
